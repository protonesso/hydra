#!/usr/bin/env bash
#

umask 0077
unalias -a

pushd() { command pushd "$1" > /dev/null; }
popd() { command popd "$1" > /dev/null; }
msg() { printf "\033[1;34m::\033[0m %s\n" "$@"; }
warn() { printf "\033[1;33m::\033[0m %s\n" "$@"; }
die() { printf "\033[1;31m::\033[0m %s\n" "$@"; exit 1; }

usage() {
	echo "USAGE"
}

get_filename() {
	local tgt

	if echo "$1" | grep -q -E '^((https|http|ftp|rtsp|mms|file)?:\/\/).+'; then
		if echo $1 | grep -q '::archive='; then
			tgt="$(echo $1 | sed -e 's/::archive=/ /g' | awk '{print $2}')"
		else
			tgt="$(basename $1)"
		fi
		echo "$srcdest/$tgt"
	else
		echo "$1"
	fi
}

parse_numbersign() {
	# $1 - kagamibuild
	# $2 - number sign variable
	[ -z "$1" ] && exit 1
	[ -z "$2" ] && exit 1

	echo "$(grep -w "^# ${2}[[:blank:]]*:" "$1" | sed "s/^# ${2}[[:blank:]]*:[[:blank:]]*//" | tr ',' ' ')"
}

check_root() {
	if [[ $EUID -ne 0 ]]; then
		die "You must be root to run 'neko'"
	fi
}

check_selinux() {
	if ! type selinuxenabled &>/dev/null; then
		return 1
	fi

	selinuxenabled
	if [ $? -ne 0 ]; then
		return 1
	else
		return 0
	fi
}

export_config() {
	[ ! -f "$1" ] && exit 1

	source "$1"

	[ "$BARCH" ] || die "Specify CPU architecture"
}

export_pkgfile() {
	# Number sign variables:
	#  Description
	#  URL
	#  Maintainer
	#  Section
	#  Depends on
	#  Dep [arch]
	#  Conflicts
	#  Provides
	#  Obsoletes

	[ ! -f "$topdir/KagamiBuild" ] && die "Package recipe not found."

	source "$topdir/KagamiBuild"

	[ -z "$name" ] && die "Package recipe is broken: package name is not specified"
	[ -z "$version" ] && die "Package recipe is broken: package version is not specified"
	[ -z "$release" ] && die "Package recipe is broken: package release is not specified"

	[ -n "$(parse_numbersign $topdir/KagamiBuild "Description")" ] \
		&& description="$(parse_numbersign $topdir/KagamiBuild "Description")"
	[ -n "$(parse_numbersign $topdir/KagamiBuild "URL")" ] \
		&& homepage="$(parse_numbersign $topdir/KagamiBuild "URL")"
	[ -n "$(parse_numbersign $topdir/KagamiBuild "Maintainer")" ] \
		&& maintainer="$(parse_numbersign $topdir/KagamiBuild "Maintainer")"
	[ -n "$(parse_numbersign $topdir/KagamiBuild "Section")" ] \
		&& section="$(parse_numbersign $topdir/KagamiBuild "Section")"
	[ -n "$(parse_numbersign $topdir/KagamiBuild "Depends on")" ] \
		&& depends="$(parse_numbersign $topdir/KagamiBuild "Depends on")"
	[ -n "$(parse_numbersign $topdir/KagamiBuild "Dep $BARCH")" ] \
		&& depends+=" $(parse_numbersign $topdir/KagamiBuild "Dep $BARCH")"
	[ -n "$(parse_numbersign $topdir/KagamiBuild "Conflicts")" ] \
		&& conflicts="$(parse_numbersign $topdir/KagamiBuild "Conflicts")"
	[ -n "$(parse_numbersign $topdir/KagamiBuild "Provides")" ] \
		&& provides="$(parse_numbersign $topdir/KagamiBuild "Provides")"
	[ -n "$(parse_numbersign $topdir/KagamiBuild "Obsoletes")" ] \
		&& obsoletes="$(parse_numbersign $topdir/KagamiBuild "Obsoletes")"
}

parse_options() {
	for myopts in ${buildoptions[@]} ${options[@]}; do
		case $myopts in
			nobootstrap) opt_bootstrap="0" ;;
			~nobootstrap) opt_bootstrap="1" ;;
			nostateless) opt_stateless="0" ;;
			~nostateless) opt_stateless="1" ;;
			ccache) opt_ccache="1" ;;
			~ccache) opt_ccache="0" ;;
			docs) opt_docs="1" ;;
			~docs) opt_docs="0" ;;
			emptydirs) opt_emptydirs="1" ;;
			~emptydirs) opt_emptydirs="0" ;;
			libtool) opt_libtool="1" ;;
			~libtool) opt_libtool="0" ;;
			locales) opt_locales="1" ;;
			~locales) opt_locales="0" ;;
			makeflags) opt_makeflags="1" ;;
			~makeflags) opt_makeflags="0" ;;
			strip) opt_strip="1" ;;
			~strip) opt_strip="0" ;;
		esac
	done
}

gitfetch() {
	local url version autover tgt

	[ -z "$1" ] && exit 1

	if echo $1 | grep -q '::checkout='; then
		url="$(echo $1 | sed 's/::checkout=/ /' | awk '{print $1}')"
		version="$(echo $1 | sed 's/::checkout=/ /' | awk '{print $2}')"
		autover="1"
	else
		url="$f"
		version=""
		autover="0"
	fi

	tgt="$(basename $url)"

	if [ ! -d "$SRC/$tgt" ]; then
		if ! type git &>/dev/null; then
			die 'Cannot download the source tarball, make sure you have `git` installed.'
		fi

		msg "Cloning git repository: $url"
		git clone $gitopts $url "$SRC/$tgt"
		if [ $? -ne 0 ]; then
			die  "Failed to clone: $url"
		fi
		if [ "$autover" == "1" ]; then
			msg "Checking out version to $version"
			pushd "$SRC/$tgt"
				git checkout tags/${version} -b branch
			popd
			if [ $? -ne 0 ]; then
				die  "Failed to check out version for $url"
			fi
		fi
	fi
}

filefetch() {
	local url archive archive_part

	[ -z "$1" ] && exit 1

	if echo $1 | grep -q '::archive='; then
		url="$(echo $1 | sed 's/::archive=/ /' | awk '{print $1}')"
		archive="$(get_filename $1)"
	else
		url="$1"
		archive="$(get_filename $1)"
	fi

	archive_part="$archive.part"

	if [ ! -f "$archive" ]; then
		if ! type curl &>/dev/null; then
			die 'Cannot download the source tarball, make sure you have `curl` installed.'
		fi

		if [ -f "$archive_part" ]; then
			msg "Resuming download of tarball: $url"
		else
			msg "Downloading tarball: $url"
		fi

		curl $curlopts -C - -f --retry 3 --retry-delay 3 -L -o "$archive_part" $url
		if [ $? -ne 0 ]; then
			rm -f "$archive_part"
			die  "Failed to download: $url"
		fi

		if [ -f "$archive_part" ] && [ ! -f "$archive" ]; then
			mv "$archive_part" "$archive"
		fi
	else
		msg "Found pre-downloaded source for $(basename $archive)"
	fi
}

download_sources() {
	local f

	if [ -n "$source" ]; then
		for f in ${source[@]}; do
			if echo "$f" | grep -q -E '^((git)?:\/\/).+'; then
				gitfetch "$f"
			elif echo "$f" | grep -q -E '^((https|http|ftp|rtsp|mms)?:\/\/).+'; then
				filefetch "$f"
			fi
		done
	fi
}

verify_sources() {
	local src filename newsum cursum

	if [ -n "$source" ]; then
		for f in ${source[@]}; do
			if echo "$f" | grep -q -E '^((git)?:\/\/).+'; then
				warn "Skipping checking sums for git repository"
				return 0
			fi

			src="$(get_filename $f)"
			filename="$(basename $src)"

			if [ "$noverify" != "yes" ] && [ -f "$topdir/hashsums" ]; then
				msg "Checking source integrity for $filename"
				cursum="$(cat $topdir/hashsums | grep $filename | awk '{print $1}')"
				newsum="$(b2sum $filename | awk '{print $1}')"

				if [ "$cursum" != "$newsum" ]; then
					[ "$noclean" != "yes" ] && rm -rf "$WORK"
					die "Failed to check source integrity for $filename"
				fi
			fi
		done
	fi
}

extract_sources() {
	local f src filename nxt noext

	if [ -n "$source" ]; then
		for f in ${source[@]}; do
			if echo "$f" | grep -q -E '^((git)?:\/\/).+'; then
				msg "Not extracting git sources for $f"
				return 0
			elif echo "$f" | grep -q -E '^((https|http|ftp|rtsp|mms)?:\/\/).+'; then
				src="$(get_filename $f)"
				filename="$(basename $src)"

				if [ -n "$noextract" ]; then
					for noext in ${noextract[@]}; do
						if [ "$noext" == "$filename" ]; then
							nxt="1"
							break
						fi
					done
				fi

				if [ "$filename" != "$f" ] && [ "$nxt" != 1 ]; then
					case $src in
						*.tar|*.tar.gz|*.tar.Z|*.tgz|*.tar.bz2|*.tbz2|*.tar.xz|*.txz|*.tar.lzma|*.tar.lz|*.tlz|*.tar.lz4|*.tar.zst|*.tar.zstd|*.zip|*.rpm|*.7z)
							msg "Extracting $filename to the sources directory"
							bsdtar -p -o -C "$SRC" -xf $src || die "Failed to extract $filename to the sources directory"
							;;
						*)
							msg "Copying $filename into sources directory"
							cp "$src" "$SRC" || die "Failed to copy $filename into sources directory"
							;;
					esac
				else
					msg "Skipping extraction of $filename"
				fi
			else
				src="$(get_filename $f)"

				msg "Copying $(basename $src) into sources directory"
				cp "$src" "$SRC" || die "Failed to copy $(basename $src) into sources directory"
			fi
		done
	fi
}

run_strip() {
	[ -z "$1" ] && exit 1

	( cd "$1"
		find . | xargs file | grep "executable" | grep ELF | cut -f 1 -d : | xargs ${CROSS_COMPILE}strip --strip-all 2>/dev/null
		find . | xargs file | grep "shared object" | grep ELF | cut -f 1 -d : | xargs ${CROSS_COMPILE}strip --strip-unneeded 2>/dev/null
		find . | xargs file | grep "current ar archive" | cut -f 1 -d : | xargs ${CROSS_COMPILE}strip --strip-debug 2>/dev/null
	)
}

setup_compiler() {
	if [ -n "$CC" ]; then
		MYCC="$CC"
	else
		MYCC="gcc"
	fi
	if [ -n "$CXX" ]; then
		MYCXX="$CXX"
	else
		MYCXX="g++"
	fi
}

build_package() {
	local use_ccache="0"

	[ "$opt_makeflags" != "0" ] && export MAKEFLAGS="$MKOPTS"

	if [ "$bootstrap" != "yes" ]; then
		if [ "$opt_ccache" != "0" ]; then
			if type ccache &>/dev/null; then
				use_ccache="1"
				if [ -d "/usr/lib64/ccache" ]; then
					ccache_path="/usr/lib64/ccache"
				elif [ -d "/usr/lib64/ccache/bin" ]; then
					ccache_path="/usr/lib64/ccache/bin"
				elif [ -d "/usr/lib/ccache" ]; then
					ccache_path="/usr/lib/ccache"
				elif [ -d "/usr/lib/ccache/bin" ]; then
					ccache_path="/usr/lib/ccache/bin"
				else
					die "ccache compilers not found"
				fi

				if [ -f "$ccache_path/${CC}" ]; then
					MYCC="$ccache_path/${CC}"
				else
					MYCC="$ccache_path/gcc"
				fi
				if [ -f "$ccache_path/${CXX}" ]; then
					MYCXX="$ccache_path/${CXX}"
				else
					MYCXX="$ccache_path/g++"
				fi
			else
				setup_compiler
			fi
		else
			setup_compiler
		fi
	fi

	if type build &>/dev/null; then
		msg "Compiling package"
		pushd "$SRC"
			(
				set -e
				if [ "$bootstrap" != "yes" ]; then
					export CC="$MYCC"
					export CXX="$MYCXX"
				fi
				build
			)
			if [ $? -ne 0 ]; then
				[ "$noclean" != "yes" ] && rm -rf "$WORK"
				die  "Failed to compile package: $name"
			fi
		popd
	else
		warn 'This package does not have `build` function. Skipping.'
	fi


	pushd "$PKG"
		mkdir -p "$SRC"/loc "$SRC"/libloc "$SRC"/helploc

		msg "Removing junk from package"
		rm -rf {,usr/}{,local/}{,share/}info usr{,/local}{,/share},opt/*}/info
		rm -rf {,usr/}{,local/}lib/charset.alias

		find . -name "*.pod" -print0 | xargs -0 rm -rf
		find . -name ".packlist" -print0 | xargs -0 rm -rf

		if [ "$opt_libtool" = "0" ]; then
			msg "Removing libtool files"
			find . -name "*.la" -print0 | xargs -0 rm -rf
		fi

		if [ "$opt_emptydirs" = "0" ]; then
				msg "Removing empty directories"
				find . -maxdepth 3 -type d -exec rmdir {} + 2>/dev/null
		fi

		if [ "$opt_locales" = "0" ]; then
			msg "Removing locales"
			rm -rf {,usr/}{,local/}{,share/,lib/}locale
		fi

		if [ "$opt_docs" = "0" ]; then
			msg "Removing documentation"
			rm -rf {,usr/}{,local/}{,share/}doc usr/{,local/}{,share/}{doc,gtk-doc} opt/*/{doc,gtk-doc}
		fi

		if [ -d "$PKG/usr/share/help" ]; then
			pushd usr/share/help
				mv C "$SRC"/

				rm -rf *

				mv "$SRC"/C .
			popd
		fi

		if [ "$opt_strip" != "0" ]; then
			msg "Removing debug information from binary files"
			run_strip "$PKG"
		fi

		msg "Compressing manual pages"
		find . -type f -path "*/man/man*/*" | while read FILE; do
			if [ "$FILE" = "${FILE%%.gz}" ]; then
				gzip -9 "$FILE"
			fi
		done

		find . -type l -path "*/man/man*/*" | while read FILE; do
			TARGET=`readlink -n "$FILE"`
			TARGET="${TARGET##*/}"
			TARGET="${TARGET%%.gz}.gz"
			rm -f "$FILE"
			FILE="${FILE%%.gz}.gz"
			DIR=`dirname "$FILE"`

			if [ -e "$DIR/$TARGET" ]; then
				ln -sf "$TARGET" "$FILE"
			fi
		done
	popd
}

compress_package() {
	local i maint getdir stateless_file

	pushd "$PKG"
		msg "Generating package metadata"

		[ -n "$maintainer" ]  && maint="$(echo $maintainer | tr -d ',' | awk '{print $1}') <$(echo $maintainer | tr -d ',' | sed 's/^\w*\ *//' | sed 's/ at /@/' | sed 's/ dot /./')>"
		cat > .PKGINFO <<-EOF
			# Generated by hydra-build $hydraversion
			# not using fakeroot at all
			pkgname = $name
			pkgver = $version
			pkgrel = r${release}
			packager = ${maint:-"Unknown"}
			builddate = $(date -u "+%s")
			size = $(du -sk | awk '{print $1 * 1024}')
			arch = $BARCH
		EOF

		[ -n "$description" ] && echo "pkgdesc = $description" >> .PKGINFO
		[ -n "$homepage" ]    && echo "url = $homepage" >> .PKGINFO
		[ -n "$section" ]     && echo "section = $section" >> .PKGINFO
		[ -n "$depends" ] && {
			for i in $depends; do
				echo "depend = $i" >> .PKGINFO
			done
		}
		[ -n "$conflicts" ] && {
			for i in $conflicts; do
				echo "conflict = $i" >> .PKGINFO
			done
		}
		[ -n "$provides" ] && {
			for i in $provides; do
				echo "provides = $i" >> .PKGINFO
			done
		}
		[ -n "$obsoletes" ] && {
			for i in $obsoletes; do
				echo "obsoletes = $i" >> .PKGINFO
			done
		}
		[ -n "$backup" ] && {
			for i in ${backup[@]}; do
				[ ! -f "$PKG/$i" ] && die "File called '${i}' does not exist"

				if [ "$opt_stateless" == "1" ]; then
					stateless_file="$(basename $i)"
					getdir="$(echo $i | sed "s/$stateless_file/ $stateless_file/" | sed 's,/[^/]*$,,')"
					
					mkdir -p usr/lib/tmpfiles.d usr/share/factory/$getdir
					mv "$PKG"/$i usr/share/factory/$getdir/$stateless_file

					echo "C! /${i}" >> usr/lib/tmpfiles.d/stateless-${name}.conf
				else
					echo "backup = $i" >> .PKGINFO
				fi
			done
		}
		if [ "$opt_stateless" == "1" ]; then
			[ ! -d "$PKG/usr/lib/tmpfiles.d" ] && mkdir -p usr/lib/tmpfiles.d

			[ -n "$makedirs" ] && {
				for i in "${makedirs[@]}"; do
					echo "d! ${i}" >> usr/lib/tmpfiles.d/setup-${name}.conf
				done
			}
			[ -n "$makelinks" ] && {
				for i in "${makelinks[@]}"; do
					echo "L! ${i}" >> usr/lib/tmpfiles.d/setup-${name}.conf
				done
			}

			rm -rf etc var
		fi

		for i in {pre,post}-{install,remove}; do
			[ -f "$topdir/$i" ] && install -Dm755 "$topdir/$i" "$PKG/$i"
		done
		[ -f "$topdir/trigger" ] && install -Dm644 "$topdir/trigger" "$PKG/usr/lib/hydra/triggers/${name}.trigger"

		check_selinux
		if [ $? -eq 0 ]; then
			msg "Relabeling package contents"
			restorecon -R "$PKG"/
		fi

		msg "Compressing package"
		find . | bsdcpio --quiet -H newc -o | brotli -Z -o "$tgt"
		if [ $? -ne 0 ]; then
			[ "$noclean" != "yes" ] && rm -rf "$WORK"
			die  "Failed to compress package"
		fi

		msg "Package was built successfuly!"
	popd
}

sign_package() {
	:
}

main() {
	local opts tgt

	export LANG="C"
	export LC_ALL="C"

	hydraversion="current"
	topdir="$PWD"
	config="/etc/hydra/make.conf"
	buildoptions=('emptydirs' 'strip' 'makeflags' 'locales' 'docs' 'ccache' 'libtool' 'nobootstrap' '~nostateless')
	bootstrap="no"
	force="no"
	noclean="no"
	nodownload="no"
	noverify="no"
	noextract="no"
	nobuild="no"
	nopackage="no"
	nosign="no"

	while getopts c:wfedvxbps opts; do
		case $opts in
			c) config="$(realpath $OPTARG)" ;;
			w) bootstrap="yes" ;;
			f) force="yes" ;;
			e) noclean="yes" ;;
			d) nodownload="yes" ;;
			v) noverify="yes" ;;
			x) noextract="yes" ;;
			b) nobuild="yes" ;;
			p) nopackage="yes" ;;
			s) nosign="yes" ;;
			\?) usage ;;
		esac
	done
	shift $((OPTIND -1))

	check_root
	export_config "$config"
	export_pkgfile
	parse_options

	[ -z "$pkgdest" ] && pkgdest="$topdir"
	[ -z "$srcdest" ] && srcdest="$topdir"

	tgt="$pkgdest/${name}-${version}+r${release}+${BARCH}.br"

	[ "$force" == "yes" ] && rm -rf "$tgt"

	if [ ! -f "$tgt" ]; then
		msg "Building package: $name"

		WORK="$PWD/work"
		PKG="$WORK/pkg"
		SRC="$WORK/src"

		rm -rf "$WORK"
		mkdir -p "$PKG" "$SRC"

		if [ "$bootstrap" = "yes" ]; then
			if [ "$opt_bootstrap" = "0" ]; then
				die "This package cannot be built in the cross-build environment"
			fi
		fi

		[ "$nodownload" != "yes" ] && download_sources
		[ "$noverify" != "yes" ]   && verify_sources
		[ "$noextract" != "yes" ]  && extract_sources
		[ "$nobuild" != "yes" ]    && build_package
		[ "$nopackage" != "yes" ]  && compress_package
		[ "$nosign" != "yes" ]     && sign_package
		[ "$noclean" != "yes" ]    && rm -rf "$WORK"
	else
		warn "Package have been built already. Skipping."
	fi
}

main "$@"

exit 0

